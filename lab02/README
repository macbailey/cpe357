--Name--
Matt Bailey (mbaile17)

--Instructions--
Program is read with stdin and stdout, for example: ./uniq < testfile > outfile

--Answers to Problems--
1. (Warm up) Please provide declarations for the following data:

	(a) a pointer cp that points to a char.
		char *cp; 
	(b) a pointer ap that points to an array of chars.
		char[] *ap;
	(c) a pointer pp that points to a pointer that points to an int.
		int *x; 
		int *pp; 
		pp = &x; 

2. Is it possible in C to declare and initialize a pointer that points to itself? Why or why not? (And, if so, how,of course.)
	yes, it is possible using pointers we can point to any memory. Even though it is not very useful or practical. 
	ex:
	int *x (int*)&x; 



3. What is the fundamental problem with the following code fragment intended to print out a string:

	char s[] = "Hello, world!\n";
	char *p;
	for(p = s; p != ’\0’; p++)
		putchar(*p);

	What will happen when this is executed? How can it be fixed?
		It will segfault, this can be fixed by changing the for loop to check if the point (*p) is at the end of an array

4. C programmers often say, “arrays are the same as pointers”. In one sense this is true.  Inanother, more correct, sense they are fundamentally different.

	(a) In what ways is this statement correct?
		Arrays hold memory that point to a value, for instance the array [0] location points to a value of 4
	(b) How is it in error? That is, what makes a pointer fundamentally different from an array?
		An array holds the memory of the value, a pointer points to the actual memory of the value 
5. The argument to perror is defined with the ISO C attribute const, whereas the integer argument to strerror isn't defined with this attribute. Why? 
	
	void perror(const char *s) is needed to be a const so that if perror modifies *s it would not affect *s in the function calling it. 
	
	On the other hand, char *strerror(int errnum) does not need to be a const because it will not modify the passed variable in the called function. 

6. If the calendar time is stored as a signed 32-bit integer, in which year will it overflow? How can we extend the overflow point? Are these strategies compatible with existing applications? 

	(a) 19 January 2038 03:14:07 UTC 
	(b) Overflow point can be remedied by changing signed time_t to and unsigned time_t that will extend the overflow to 2106. Another option would be to change from 	ISO 9660 & ISO 13346 date strings to ISO 8601 date strings. Or change all systems to 64-bit systems 
	(c) These strategies could be compatible but might lose other compatibilities in outside systems.  

7. A subcase of Ex 2.2 from Stevens: On unix5 what is the actual data type of a size_t (the type of malloc()'s argument)? In what header file is it defined? 
	(a) size_t is data type of an unsigned integer type. 
	(b) The header file that defines it is <stdlib.h>
